#!/usr/bin/env bash
# sync-security-incidents.sh
# shellcheck shell=bash
#
# Auto-generate the Renovate security incidents aggregator preset
#
# Usage
#   ./sync-security-incidents.sh [--aggregator <output_json>]
#   ./sync-security-incidents.sh --help
#
# Behavior
# - Collect all JSON presets under the incidents dir (security/incidents/**)
# - Generate the aggregator JSON (default security/_incidents.json) with a sorted 'extends' array

set -euo pipefail
IFS=$'\n\t'

INCIDENTS_DIR="security/incidents"
AGGREGATOR_JSON="security/_incidents.json"
PRESET_PREFIX="bartsmykla/public-shared-renovate//"

print_usage() {
  cat <<USAGE
Usage: $0 [--aggregator <path>] [--help]

Options:
  --aggregator <path>  Output aggregator JSON path (default: ${AGGREGATOR_JSON})
  -h, --help           Show this help and exit
USAGE
}

# Ensure the next token exists and isn't another flag
require_arg() {
  local opt=$1 val=${2-}
  [[ -n "$val" && ! "$val" =~ ^- ]] || die "missing value for $opt"
}

parse_flags() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --aggregator)
        require_arg "$1" "${2-}"
        AGGREGATOR_JSON="$2"; shift 2;;
      -h|--help)
        print_usage; exit 0;;
      --)
        shift; break;;
      *)
        die "unknown option: $1";;
    esac
  done
}

# If the message already contains a GitHub annotation prefix (::level::), print as-is.
# Otherwise, prefix with the requested level
__emit() {
  local level=$1
  shift || true
  local msg="$*"

  if [[ "$msg" == *"::"* ]]; then
    printf '%s\n' "$msg"
  elif [[ -n "$level" ]]; then
    printf '::%s::%s\n' "$level" "$msg"
  else
    printf '%s\n' "$msg"
  fi
}

log()    { __emit ""        "$@"; }
notice() { __emit "notice"  "$@"; }
debug()  { __emit "debug"   "$@"; }
warn()   { __emit "warning" "$@"; }
error()  { __emit "error"   "$@"; }
die()    { error "$@"; exit 1; }

# Usage: require_tools git jq ...
require_tools() {
  local missing=() t
  for t in "$@"; do
    command -v "$t" >/dev/null 2>&1 || missing+=("$t")
  done
  (( ${#missing[@]} == 0 )) || die "missing required tools: ${missing[*]}"
}

ensure_repo() {
  git rev-parse --git-dir >/dev/null 2>&1 || die "not a git repository"
}

# Strip leading ./ for stable ids
relpath() {
  local p=$1
  case "$p" in
  ./*) printf '%s\n' "${p#./}" ;;
  *)   printf '%s\n' "$p" ;;
  esac
}

# Remove .json suffix if present
strip_json_ext() {
  local p=$1
  printf '%s\n' "${p%.json}"
}

# Example: prefix=bartsmykla/public-shared-renovate// rel=security/incidents/foo
preset_id_from_rel_noext() {
  local prefix=$1 rel_no_ext=$2
  printf '%s%s\n' "$prefix" "$rel_no_ext"
}

# List incident files, nul-delimited, stable sort
collect_incident_files() {
  local files
  mapfile -d '' -t files < <(
    find "$INCIDENTS_DIR" -type f -name '*.json' -print0 | sort -z
  )
  printf '%s\0' "${files[@]}"
}

# Output sorted unique preset ids (one per line)
sorted_incident_ids() {
  local -a ids=()
  local f rel rel_no_ext id
  while IFS= read -r -d '' f; do
    rel=$(relpath "$f")
    rel_no_ext=$(strip_json_ext "$rel")
    id=$(preset_id_from_rel_noext "$PRESET_PREFIX" "$rel_no_ext")
    ids+=("$id")
  done < <(collect_incident_files)

  ((${#ids[@]})) && printf '%s\n' "${ids[@]}" | sort -u
}

# Print final JSON to stdout
generate_json() {
  local ids extends_json
  ids="$(sorted_incident_ids || true)"
  extends_json="$(
    printf '%s\n' "${ids:-}" | jq -R -s 'split("\n") | map(select(length>0))'
  )"

  jq -n \
    --argjson extends "${extends_json:-[]}" \
    --arg schema "https://docs.renovatebot.com/renovate-schema.json" \
    --arg d1 " [AUTOGENERATED] Do not edit this file manually." \
    --arg d2 " This aggregator preset is maintained by CI and composes all presets under" \
    --arg d3 " security/incidents/**. To add or remove an incident rule, modify files in" \
    --arg d4 " security/incidents/ and open a PR. The CI workflow will update this file" \
    --arg d5 " in your PR and keep entries sorted alphabetically." \
    '{
      "$schema": $schema,
      "description": [$d1,$d2,$d3,$d4,$d5],
      "extends": $extends
    }'
}

# Write only if content changed; return 0 if changed, 1 otherwise
write_if_changed() {
  local tmp
  tmp="$(mktemp)"
  generate_json > "$tmp"

  if [[ ! -f "$AGGREGATOR_JSON" ]] || ! diff -u "$AGGREGATOR_JSON" "$tmp" > /dev/null 2>&1; then
    mkdir -p "$(dirname "$AGGREGATOR_JSON")"
    mv "$tmp" "$AGGREGATOR_JSON"
    log "updated $AGGREGATOR_JSON"
    return 0
  fi

  rm -f "$tmp"
  log "no changes in $AGGREGATOR_JSON"
  return 1
}

main() {
  # Parse CLI flags first to allow overriding defaults
  parse_flags "$@"

  require_tools jq git

  if [[ ! -d $INCIDENTS_DIR ]]; then
    log "no $INCIDENTS_DIR directory, nothing to do"
    exit 0
  fi

  # Generate and write aggregator if content differs
  write_if_changed || true
}

# Allow sourcing
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
